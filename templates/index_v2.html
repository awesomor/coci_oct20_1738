<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Wave Player + RMS VAD Chunking</title>
  <link rel="stylesheet" href="/static/style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <main class="container">
    <h1>ğŸ§ Wave Player + RMS ê¸°ë°˜ ì²­í‚¹(0.6s ë¬´ìŒ)</h1>

    <!-- ì˜¤ë””ì˜¤ í”Œë ˆì´ì–´ -->
    <audio id="player" src="/media/sample.wav" controls class="audio"></audio>

    <!-- íŒŒí˜• ìº”ë²„ìŠ¤ -->
    <canvas id="wave-canvas" class="wave"></canvas>

    <!-- ì²­í¬ íƒ€ì„ë¼ì¸ (ì²­í¬ êµ¬ê°„ì´ ì´ˆë¡ ë§‰ëŒ€ë¡œ í‘œì‹œë¨) -->
    <div class="row">
      <label class="label">Chunks</label>
      <canvas id="chunk-canvas" class="chunk-timeline"></canvas>
    </div>

    <!-- ìƒíƒœ UI -->
    <div class="grid">
      <div>
        <div class="label">RMS (100ms)</div>
        <div id="rms-val" class="mono">0.0000</div>
      </div>
      <div>
        <div class="label">Threshold</div>
        <input id="thresh" type="range" min="0.01" max="0.10" step="0.005" value="0.03" />
        <div><span class="mono" id="thresh-val">0.03</span></div>
      </div>
      <div>
        <div class="label">Voice</div>
        <div id="voice-box" class="voice-indicator off"></div>
      </div>
      <div>
        <div class="label">Silence (ms)</div>
        <div id="silence-ms" class="mono">0</div>
      </div>
      <div>
        <div class="label">Controls</div>
        <button id="clear-btn" class="btn">Clear Chunks</button>
      </div>
    </div>

    <!-- ì²­í¬ ë¡œê·¸ -->
    <div class="row">
      <label class="label">Chunk Log</label>
      <div id="chunk-log" class="chunk-log"></div>
    </div>
  </main>

  <script>
    // ====== ê¸°ë³¸ ìƒìˆ˜ ======
    const SILENCE_MS_TO_SPLIT = 600;   // 0.6ì´ˆ ë¬´ìŒ ì§€ì† ì‹œ ì²­í¬ ì¢…ë£Œ
    const RMS_WINDOW_SEC = 0.1;        // 100ms RMS ê³„ì‚° ì°½
    const POLL_MS = 100;               // 100ms ì£¼ê¸°

    // ====== ì—˜ë¦¬ë¨¼íŠ¸ ======
    const playerEl = document.getElementById('player');
    const waveCanvas = document.getElementById('wave-canvas');
    const chunkCanvas = document.getElementById('chunk-canvas');
    const voiceBox = document.getElementById('voice-box');
    const rmsValEl = document.getElementById('rms-val');
    const threshEl = document.getElementById('thresh');
    const threshValEl = document.getElementById('thresh-val');
    const silenceMsEl = document.getElementById('silence-ms');
    const chunkLogEl = document.getElementById('chunk-log');
    const clearBtn = document.getElementById('clear-btn');

    // ====== ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸/ë²„í¼ ======
    let audioCtx = null;
    let audioBuffer = null;
    let channelData = null;
    let sampleRate = 48000;

    // ====== ìƒíƒœ ë¨¸ì‹  ======
    let threshold = parseFloat(threshEl.value);
    let pollingTimer = null;

    let isSpeaking = false;
    let currentChunkStart = null; // ì´ˆ ë‹¨ìœ„
    let silenceAccumMs = 0;
    const chunks = []; // {start: number(sec), end: number(sec)}

    // ====== ìœ í‹¸ ======
    function calculateRMS(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        const v = samples[i];
        sum += v * v;
      }
      return Math.sqrt(sum / Math.max(1, samples.length));
    }

    function formatSec(sec) {
      return (Math.max(0, sec)).toFixed(2) + 's';
    }

    function logChunk(c) {
      const div = document.createElement('div');
      div.className = 'chunk-item';
      div.textContent = `ğŸŸ© Chunk ${chunks.length}: ${formatSec(c.start)} ~ ${formatSec(c.end)} (len ${(c.end - c.start).toFixed(2)}s)`;
      chunkLogEl.prepend(div);
    }

    function drawWaveform() {
      const ctx = waveCanvas.getContext('2d');
      const w = waveCanvas.width = waveCanvas.clientWidth;
      const h = waveCanvas.height = waveCanvas.clientHeight;

      ctx.clearRect(0, 0, w, h);
      if (!channelData) return;

      ctx.lineWidth = 1;
      ctx.beginPath();

      const step = Math.ceil(channelData.length / w);
      const mid = h / 2;
      for (let x = 0; x < w; x++) {
        const start = x * step;
        const end = Math.min(start + step, channelData.length);
        let min = 1.0, max = -1.0;
        for (let i = start; i < end; i++) {
          const v = channelData[i];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        ctx.moveTo(x, (1 - min) * mid);
        ctx.lineTo(x, (1 - max) * mid);
      }
      ctx.stroke();
    }

    function drawChunks() {
      const ctx = chunkCanvas.getContext('2d');
      const w = chunkCanvas.width = chunkCanvas.clientWidth;
      const h = chunkCanvas.height = chunkCanvas.clientHeight;

      ctx.clearRect(0, 0, w, h);

      if (!audioBuffer) return;
      const dur = audioBuffer.duration;

      // ì „ì²´ ë°” í‹€
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      // ì´ë¯¸ í™•ì •ëœ ì²­í¬
      ctx.globalAlpha = 0.6;
      for (const c of chunks) {
        const x1 = (c.start / dur) * w;
        const x2 = (c.end / dur) * w;
        ctx.fillRect(x1, 0, Math.max(1, x2 - x1), h);
      }
      ctx.globalAlpha = 1.0;

      // ì§„í–‰ ì¤‘ì¸ ì²­í¬(ë§í•˜ëŠ” ì¤‘) ì‹œê°í™”
      if (isSpeaking && currentChunkStart != null) {
        const now = Math.min(playerEl.currentTime, dur);
        const x1 = (currentChunkStart / dur) * w;
        const x2 = (now / dur) * w;
        ctx.fillRect(x1, 0, Math.max(1, x2 - x1), h);
      }

      // í”Œë ˆì´í—¤ë“œ
      const headX = (playerEl.currentTime / dur) * w;
      ctx.beginPath();
      ctx.moveTo(headX, 0);
      ctx.lineTo(headX, h);
      ctx.stroke();
    }

    function setVoice(on) {
      voiceBox.classList.toggle('on', !!on);
      voiceBox.classList.toggle('off', !on);
    }

    // ====== í´ë§ ë£¨í”„ (100ms) ======
    function poll() {
      if (!audioBuffer) return;

      const sr = sampleRate;
      const windowSize = Math.floor(RMS_WINDOW_SEC * sr);

      const endIndex = Math.floor(playerEl.currentTime * sr);
      const startIndex = Math.max(0, endIndex - windowSize);

      const samples = channelData.subarray(startIndex, endIndex);
      const rms = calculateRMS(samples);

      // UI ì—…ë°ì´íŠ¸
      rmsValEl.textContent = rms.toFixed(4);
      setVoice(rms > threshold);

      // ìƒíƒœ ë¨¸ì‹ 
      const speakingNow = rms > threshold;

      if (speakingNow) {
        // ë§í•˜ëŠ” ì¤‘
        if (!isSpeaking) {
          // ìƒˆ ì²­í¬ ì‹œì‘
          isSpeaking = true;
          // ì²­í¬ ì‹œì‘ ì‹œì ì„ "ì§€ê¸ˆ - ìœˆë„ìš°"ë¡œ ì‚´ì§ ë‹¹ê²¨ ì‹œì‘ê° ëˆ„ë½ ë°©ì§€
          currentChunkStart = Math.max(0, playerEl.currentTime - RMS_WINDOW_SEC);
          silenceAccumMs = 0;
        } else {
          // ê³„ì† ë§í•˜ëŠ” ì¤‘ â†’ ë¬´ìŒ ëˆ„ì  ì¹´ìš´í„° ë¦¬ì…‹
          silenceAccumMs = 0;
        }
      } else {
        // ë¬´ìŒ
        if (isSpeaking) {
          silenceAccumMs += POLL_MS;
          if (silenceAccumMs >= SILENCE_MS_TO_SPLIT) {
            // ì²­í¬ ì¢…ë£Œ = í˜„ì¬ì‹œê°„ - ëˆ„ì  ë¬´ìŒ
            const chunkEnd = Math.max(0, playerEl.currentTime - (silenceAccumMs / 1000));
            if (currentChunkStart != null && chunkEnd - currentChunkStart > 0.05) {
              const chunk = { start: currentChunkStart, end: chunkEnd };
              chunks.push(chunk);
              logChunk(chunk);
            }
            // ë¦¬ì…‹
            isSpeaking = false;
            currentChunkStart = null;
            silenceAccumMs = 0;
          }
        } else {
          // ì´ë¯¸ ë¬´ìŒ ìƒíƒœ ìœ ì§€
          silenceAccumMs = Math.min(silenceAccumMs + POLL_MS, SILENCE_MS_TO_SPLIT);
        }
      }

      silenceMsEl.textContent = silenceAccumMs.toString();

      // ê·¸ë¦¬ê¸°
      drawChunks();
    }

    // ====== ë¡œë”© & ì´ˆê¸°í™” ======
    async function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const res = await fetch(playerEl.src);
      const arrayBuf = await res.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuf);
      sampleRate = audioBuffer.sampleRate;
      channelData = audioBuffer.getChannelData(0);

      // ì´ˆê¸° ë Œë”
      drawWaveform();
      drawChunks();

      // í´ë§ ì‹œì‘ (ì´ë¯¸ ì¬ìƒ ì¤‘ì´ë“  ì•„ë‹ˆë“ , í™”ë©´ ê°±ì‹ ìš©)
      if (!pollingTimer) {
        pollingTimer = setInterval(poll, POLL_MS);
      }
    }

    // ====== ì´ë²¤íŠ¸ ë°”ì¸ë”© ======
    playerEl.addEventListener('play', () => {
      audioCtx && audioCtx.resume();
    });

    playerEl.addEventListener('seeked', () => {
      // ì‹œí¬ ì‹œ ë¬´ìŒ ëˆ„ì /ìƒíƒœ ì•½í•˜ê²Œ ë¦¬ì…‹í•´ì„œ ì•ˆì •í™”
      silenceAccumMs = 0;
      if (!playerEl.paused) {
        // ì‹œí¬ í›„ ì§ì „ êµ¬ê°„ì´ ë¬´ìŒì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ë‹¤ìŒ í´ë§ì—ì„œ ìì—° ì²˜ë¦¬
      }
      drawChunks();
    });

    playerEl.addEventListener('ended', () => {
      // ëì—ì„œ ë§í•˜ëŠ” ì¤‘ì´ì—ˆë‹¤ë©´ ì²­í¬ ë§ˆë¬´ë¦¬
      if (isSpeaking && currentChunkStart != null) {
        const chunk = { start: currentChunkStart, end: audioBuffer.duration };
        chunks.push(chunk);
        logChunk(chunk);
      }
      isSpeaking = false;
      currentChunkStart = null;
      silenceAccumMs = 0;
      drawChunks();
    });

    threshEl.addEventListener('input', (e) => {
      threshold = parseFloat(e.target.value);
      threshValEl.textContent = threshold.toFixed(3);
    });

    clearBtn.addEventListener('click', () => {
      chunks.length = 0;
      isSpeaking = false;
      currentChunkStart = null;
      silenceAccumMs = 0;
      chunkLogEl.innerHTML = '';
      drawChunks();
    });

    window.addEventListener('resize', () => {
      drawWaveform();
      drawChunks();
    });

    // ì‹œì‘
    initAudio();
  </script>
</body>
</html>
