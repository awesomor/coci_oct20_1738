<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Wave Player + RMS VAD Chunking</title>
  <link rel="stylesheet" href="/static/style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <main class="container">
    <h1>🎧 Wave Player + RMS 기반 청킹(0.6s 무음)</h1>

    <!-- 오디오 플레이어 -->
    <audio id="player" src="/media/sample.wav" controls class="audio"></audio>

    <!-- 파형 캔버스 -->
    <canvas id="wave-canvas" class="wave"></canvas>

    <!-- 청크 타임라인 (청크 구간이 초록 막대로 표시됨) -->
    <div class="row">
      <label class="label">Chunks</label>
      <canvas id="chunk-canvas" class="chunk-timeline"></canvas>
    </div>

    <!-- 상태 UI -->
    <div class="grid">
      <div>
        <div class="label">RMS (100ms)</div>
        <div id="rms-val" class="mono">0.0000</div>
      </div>
      <div>
        <div class="label">Threshold</div>
        <input id="thresh" type="range" min="0.01" max="0.10" step="0.005" value="0.03" />
        <div><span class="mono" id="thresh-val">0.03</span></div>
      </div>
      <div>
        <div class="label">Voice</div>
        <div id="voice-box" class="voice-indicator off"></div>
      </div>
      <div>
        <div class="label">Silence (ms)</div>
        <div id="silence-ms" class="mono">0</div>
      </div>
      <div>
        <div class="label">Controls</div>
        <button id="clear-btn" class="btn">Clear Chunks</button>
      </div>
    </div>

    <!-- 청크 로그 -->
    <div class="row">
      <label class="label">Chunk Log</label>
      <div id="chunk-log" class="chunk-log"></div>
    </div>
  </main>

  <script>
    // ====== 기본 상수 ======
    const SILENCE_MS_TO_SPLIT = 600;   // 0.6초 무음 지속 시 청크 종료
    const RMS_WINDOW_SEC = 0.1;        // 100ms RMS 계산 창
    const POLL_MS = 100;               // 100ms 주기

    // ====== 엘리먼트 ======
    const playerEl = document.getElementById('player');
    const waveCanvas = document.getElementById('wave-canvas');
    const chunkCanvas = document.getElementById('chunk-canvas');
    const voiceBox = document.getElementById('voice-box');
    const rmsValEl = document.getElementById('rms-val');
    const threshEl = document.getElementById('thresh');
    const threshValEl = document.getElementById('thresh-val');
    const silenceMsEl = document.getElementById('silence-ms');
    const chunkLogEl = document.getElementById('chunk-log');
    const clearBtn = document.getElementById('clear-btn');

    // ====== 오디오 컨텍스트/버퍼 ======
    let audioCtx = null;
    let audioBuffer = null;
    let channelData = null;
    let sampleRate = 48000;

    // ====== 상태 머신 ======
    let threshold = parseFloat(threshEl.value);
    let pollingTimer = null;

    let isSpeaking = false;
    let currentChunkStart = null; // 초 단위
    let silenceAccumMs = 0;
    const chunks = []; // {start: number(sec), end: number(sec)}

    // ====== 유틸 ======
    function calculateRMS(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        const v = samples[i];
        sum += v * v;
      }
      return Math.sqrt(sum / Math.max(1, samples.length));
    }

    function formatSec(sec) {
      return (Math.max(0, sec)).toFixed(2) + 's';
    }

    function logChunk(c) {
      const div = document.createElement('div');
      div.className = 'chunk-item';
      div.textContent = `🟩 Chunk ${chunks.length}: ${formatSec(c.start)} ~ ${formatSec(c.end)} (len ${(c.end - c.start).toFixed(2)}s)`;
      chunkLogEl.prepend(div);
    }

    function drawWaveform() {
      const ctx = waveCanvas.getContext('2d');
      const w = waveCanvas.width = waveCanvas.clientWidth;
      const h = waveCanvas.height = waveCanvas.clientHeight;

      ctx.clearRect(0, 0, w, h);
      if (!channelData) return;

      ctx.lineWidth = 1;
      ctx.beginPath();

      const step = Math.ceil(channelData.length / w);
      const mid = h / 2;
      for (let x = 0; x < w; x++) {
        const start = x * step;
        const end = Math.min(start + step, channelData.length);
        let min = 1.0, max = -1.0;
        for (let i = start; i < end; i++) {
          const v = channelData[i];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        ctx.moveTo(x, (1 - min) * mid);
        ctx.lineTo(x, (1 - max) * mid);
      }
      ctx.stroke();
    }

    function drawChunks() {
      const ctx = chunkCanvas.getContext('2d');
      const w = chunkCanvas.width = chunkCanvas.clientWidth;
      const h = chunkCanvas.height = chunkCanvas.clientHeight;

      ctx.clearRect(0, 0, w, h);

      if (!audioBuffer) return;
      const dur = audioBuffer.duration;

      // 전체 바 틀
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      // 이미 확정된 청크
      ctx.globalAlpha = 0.6;
      for (const c of chunks) {
        const x1 = (c.start / dur) * w;
        const x2 = (c.end / dur) * w;
        ctx.fillRect(x1, 0, Math.max(1, x2 - x1), h);
      }
      ctx.globalAlpha = 1.0;

      // 진행 중인 청크(말하는 중) 시각화
      if (isSpeaking && currentChunkStart != null) {
        const now = Math.min(playerEl.currentTime, dur);
        const x1 = (currentChunkStart / dur) * w;
        const x2 = (now / dur) * w;
        ctx.fillRect(x1, 0, Math.max(1, x2 - x1), h);
      }

      // 플레이헤드
      const headX = (playerEl.currentTime / dur) * w;
      ctx.beginPath();
      ctx.moveTo(headX, 0);
      ctx.lineTo(headX, h);
      ctx.stroke();
    }

    function setVoice(on) {
      voiceBox.classList.toggle('on', !!on);
      voiceBox.classList.toggle('off', !on);
    }

    // ====== 폴링 루프 (100ms) ======
    function poll() {
      if (!audioBuffer) return;

      const sr = sampleRate;
      const windowSize = Math.floor(RMS_WINDOW_SEC * sr);

      const endIndex = Math.floor(playerEl.currentTime * sr);
      const startIndex = Math.max(0, endIndex - windowSize);

      const samples = channelData.subarray(startIndex, endIndex);
      const rms = calculateRMS(samples);

      // UI 업데이트
      rmsValEl.textContent = rms.toFixed(4);
      setVoice(rms > threshold);

      // 상태 머신
      const speakingNow = rms > threshold;

      if (speakingNow) {
        // 말하는 중
        if (!isSpeaking) {
          // 새 청크 시작
          isSpeaking = true;
          // 청크 시작 시점을 "지금 - 윈도우"로 살짝 당겨 시작감 누락 방지
          currentChunkStart = Math.max(0, playerEl.currentTime - RMS_WINDOW_SEC);
          silenceAccumMs = 0;
        } else {
          // 계속 말하는 중 → 무음 누적 카운터 리셋
          silenceAccumMs = 0;
        }
      } else {
        // 무음
        if (isSpeaking) {
          silenceAccumMs += POLL_MS;
          if (silenceAccumMs >= SILENCE_MS_TO_SPLIT) {
            // 청크 종료 = 현재시간 - 누적 무음
            const chunkEnd = Math.max(0, playerEl.currentTime - (silenceAccumMs / 1000));
            if (currentChunkStart != null && chunkEnd - currentChunkStart > 0.05) {
              const chunk = { start: currentChunkStart, end: chunkEnd };
              chunks.push(chunk);
              logChunk(chunk);
            }
            // 리셋
            isSpeaking = false;
            currentChunkStart = null;
            silenceAccumMs = 0;
          }
        } else {
          // 이미 무음 상태 유지
          silenceAccumMs = Math.min(silenceAccumMs + POLL_MS, SILENCE_MS_TO_SPLIT);
        }
      }

      silenceMsEl.textContent = silenceAccumMs.toString();

      // 그리기
      drawChunks();
    }

    // ====== 로딩 & 초기화 ======
    async function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const res = await fetch(playerEl.src);
      const arrayBuf = await res.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuf);
      sampleRate = audioBuffer.sampleRate;
      channelData = audioBuffer.getChannelData(0);

      // 초기 렌더
      drawWaveform();
      drawChunks();

      // 폴링 시작 (이미 재생 중이든 아니든, 화면 갱신용)
      if (!pollingTimer) {
        pollingTimer = setInterval(poll, POLL_MS);
      }
    }

    // ====== 이벤트 바인딩 ======
    playerEl.addEventListener('play', () => {
      audioCtx && audioCtx.resume();
    });

    playerEl.addEventListener('seeked', () => {
      // 시크 시 무음 누적/상태 약하게 리셋해서 안정화
      silenceAccumMs = 0;
      if (!playerEl.paused) {
        // 시크 후 직전 구간이 무음일 수 있으니 다음 폴링에서 자연 처리
      }
      drawChunks();
    });

    playerEl.addEventListener('ended', () => {
      // 끝에서 말하는 중이었다면 청크 마무리
      if (isSpeaking && currentChunkStart != null) {
        const chunk = { start: currentChunkStart, end: audioBuffer.duration };
        chunks.push(chunk);
        logChunk(chunk);
      }
      isSpeaking = false;
      currentChunkStart = null;
      silenceAccumMs = 0;
      drawChunks();
    });

    threshEl.addEventListener('input', (e) => {
      threshold = parseFloat(e.target.value);
      threshValEl.textContent = threshold.toFixed(3);
    });

    clearBtn.addEventListener('click', () => {
      chunks.length = 0;
      isSpeaking = false;
      currentChunkStart = null;
      silenceAccumMs = 0;
      chunkLogEl.innerHTML = '';
      drawChunks();
    });

    window.addEventListener('resize', () => {
      drawWaveform();
      drawChunks();
    });

    // 시작
    initAudio();
  </script>
</body>
</html>
