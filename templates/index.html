<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Wave Player + Whisper(STT) + Similarity + Scene Background (Box)</title>
  <link rel="stylesheet" href="/static/style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <main class="container">
    <h1>ğŸ§ ì¬ìƒ + ğŸ­ ë°°ê²½(ë°•ìŠ¤) + ğŸ“œ ìŠ¤í¬ë¦½íŠ¸</h1>

    <div class="main-layout">
      <!-- Left: ì˜¤ë””ì˜¤ + ë°°ê²½ ë°•ìŠ¤ -->
      <section class="left-panel">
        <audio id="player" src="/media/sample.wav" controls class="audio"></audio>

        <!-- ğŸ¨ í° ì‚¬ê°í˜• ë°°ê²½ ë°•ìŠ¤ (ì”¬ ì „í™˜ ì „ìš©, ë‚´ë¶€ í˜ì´ë“œ ë ˆì´ì–´ 2ì¥) -->
        <div id="bg-box" class="bg-box">
          <div id="boxA" class="bg-box-layer"></div>
          <div id="boxB" class="bg-box-layer"></div>
        <!-- ğŸ§‘ Actor overlay (two frames: mouth closed / open) -->
        <div id="actor" class="actor">
          <img id="actor-closed" class="actor-frame show" src="/static/actor/closed.png" alt="actor-closed" />
          <img id="actor-open" class="actor-frame" src="/static/actor/open.png" alt="actor-open" />
        </div>

      </section>

      <!-- Right: ìŠ¤í¬ë¦½íŠ¸ íŒ¨ë„ (ìœ ì§€) -->
      <aside class="right-panel">
        <div class="script-header">
          <div class="script-title">ğŸ“œ ìŠ¤í¬ë¦½íŠ¸ (Scene-aware)</div>
          <div class="script-meta mono"><span id="script-count">0</span> lines / <span id="scene-count">0</span> scenes</div>
        </div>
        <div id="script-box" class="script-box"></div>
      </aside>
    </div>
  </main>

  <script>
    // ===========================
    // ìƒìˆ˜/ì„¤ì •
    // ===========================
    let isTalkingVisual = false;  
    // (ì„ íƒ) ë¯¸ì„¸ ë–¨ë¦¼ ë°©ì§€ìš© íˆìŠ¤í…Œë¦¬ì‹œìŠ¤
    const TALK_ON_FACTOR  = 1.00;  // threshold * 1.00 ì´ˆê³¼ ì‹œ "ë§í•¨" ì§„ì…
    const TALK_OFF_FACTOR = 0.95;  // threshold * 0.95 ë¯¸ë§Œ ì‹œ "ì¹¨ë¬µ" ë³µê·€

    // ìœ ì‚¬ë„ ìœˆë„ìš° ê²€ìƒ‰ìš© ìƒíƒœ
    let lastBestIdx = null;                   // ì§ì „ ìµœê³  ë§¤ì¹˜ ì¸ë±ìŠ¤
    const WINDOW_BACK = 2;                    // ë’¤ë¡œ 2
    const WINDOW_AHEAD = 3;                   // ì•ìœ¼ë¡œ 3
    const SILENCE_MS_TO_SPLIT = 1000;   // 1.0s ë¬´ìŒìœ¼ë¡œ ì²­í¬ ëŠê¸°
    const RMS_WINDOW_SEC = 0.1;         // 100ms RMS
    const POLL_MS = 100;                // 100ms ê°„ê²©
    const MATCH_THRESHOLD = 90;         // ìœ ì‚¬ë„ í•˜ì´ë¼ì´íŠ¸ ê¸°ì¤€
    const BG_BASE = '/static/bg/scene'; // ì”¬ ë°°ê²½ ê²½ë¡œ prefix
    const FIXED_THRESHOLD = 0.03;       // UI ìŠ¬ë¼ì´ë” ì œê±° â†’ ê³ ì • ì„ê³„ê°’

    // ì”¬ ì§„í–‰ë„ ì¶”ì : sceneId -> Set(ì´ ì”¬ì—ì„œ 90%â†‘ ë§¤ì¹˜ëœ ì¤„ idx)
    const sceneProgress = new Map();

    // ===========================
    // ì—˜ë¦¬ë¨¼íŠ¸
    // ===========================
    const playerEl = document.getElementById('player');
    const scriptCountEl = document.getElementById('script-count');
    const sceneCountEl = document.getElementById('scene-count');
    const scriptBoxEl = document.getElementById('script-box');

    // ë°°ê²½ ë°•ìŠ¤ì˜ 2ì¤‘ ë ˆì´ì–´ (í˜ì´ë“œ ì „í™˜)
    const boxA = document.getElementById('boxA');
    const boxB = document.getElementById('boxB');

    // === Actor overlay control (two-frame lip sync) ===================
    const ACTOR_FRAME_MS = 100; // ë§í•  ë•Œ í”„ë ˆì„ ì „í™˜ ê°„ê²© (ì›í•˜ë©´ 120~200ms ì¡°ì ˆ)
    const actorEl = document.getElementById('actor');
    const actorClosedEl = document.getElementById('actor-closed');
    const actorOpenEl = document.getElementById('actor-open');
    let speakingTimer = null;
    let speakToggle = false;

    let activeBg = 'A';
    let currentScene = 0;

    // ===========================
    // ì˜¤ë””ì˜¤ ë²„í¼
    // ===========================
    let audioCtx = null;
    let audioBuffer = null;
    let channelData = null;
    let sampleRate = 48000;

    // ===========================
    // ìƒíƒœ
    // ===========================
    let threshold = FIXED_THRESHOLD;
    let pollingTimer = null;

    let isSpeaking = false;
    let currentChunkStart = null; // seconds
    let silenceAccumMs = 0;
    const chunks = []; // {start, end, text, total_s, stt_s, net_s, sim_pct}

    // Scene-aware ë°ì´í„°
    let scriptLines = [];           // [{idx, text, scene}]
    let sceneCount = 0;             // ì´ ì”¬ ìˆ˜
    let linesByScene = new Map();   // scene -> [idx,...]
    let lastIdxByScene = new Map(); // scene -> ë§ˆì§€ë§‰ ì¤„ idx
    let completedScenes = new Set();// ì „í™˜ ì™„ë£Œëœ scene ì €ì¥

    
    // ===========================
    // ìœ í‹¸
    // ===========================
    function calculateRMS(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) sum += samples[i] * samples[i];
      return Math.sqrt(sum / Math.max(1, samples.length));
    }
    function formatSec(sec) { return (Math.max(0, sec)).toFixed(2) + 's'; }

    // ===========================
    // ğŸ­ Scene ì „í™˜: ë°°ê²½ ë°•ìŠ¤ ë‚´ë¶€ ì´ë¯¸ì§€ í˜ì´ë“œ
    // ===========================
    function changeBackground(nextScene) {
      if (typeof nextScene !== 'number') return;
      if (nextScene < 0) nextScene = 0;
      if (sceneCount > 0 && nextScene > sceneCount) nextScene = sceneCount;

      const nextUrl = `${BG_BASE}${nextScene}.jpg`;

      if (activeBg === 'A') {
        boxB.style.backgroundImage = `url("${nextUrl}")`;
        boxB.classList.add('show');
        boxA.classList.remove('show');
        activeBg = 'B';
      } else {
        boxA.style.backgroundImage = `url("${nextUrl}")`;
        boxA.classList.add('show');
        boxB.classList.remove('show');
        activeBg = 'A';
      }
      currentScene = nextScene;
    }

    // âœ… ë§ˆì§€ë§‰ ì¤„ì´ë©´ ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì „í™˜
    // ğŸ­ íŠ¸ë¦¬ê±°: â€œí•´ë‹¹ ì”¬ ëª¨ë“  ì¤„ì´ 90%â†‘ë¡œ ìµœì†Œ 1íšŒ ê°ì§€â€ + â€œë§ˆì§€ë§‰ ì¤„ ê°ì§€â€
    function checkSceneTrigger(bestIdx, pct) {
      if (bestIdx == null || pct < MATCH_THRESHOLD) return;

      const line = scriptLines.find(l => l.idx === bestIdx);
      if (!line) return;
      const sceneId = line.scene || 1;

      const lastIdx = lastIdxByScene.get(sceneId);
      if (lastIdx == null) return;

      const allPassed = isSceneCompletedByScore(sceneId);
      if (bestIdx === lastIdx && allPassed) {
        if (!completedScenes.has(sceneId)) {
          completedScenes.add(sceneId);
          changeBackground(sceneId + 1);
        }
      }
    }


    // ëª¨ë“  ì¤„ì´ 90%â†‘ ë‹¬ì„±í–ˆëŠ”ì§€ ê²€ì‚¬
    function isSceneCompletedByScore(sceneId) {
      const arr = linesByScene.get(sceneId) || [];
      const done = sceneProgress.get(sceneId);
      return done && done.size >= arr.length;
    }

    // í›„ë³´ ì¸ë±ìŠ¤ ìœˆë„ìš° ìƒì„±
    function makeCandidateWindow(centerIdx) {
      if (centerIdx == null) return null; // nullì´ë©´ ì„œë²„ì—ì„œ ì „ì²´ ë¹„êµ
      const min = Math.max(0, centerIdx - WINDOW_BACK);
      const max = Math.min(scriptLines.length - 1, centerIdx + WINDOW_AHEAD);
      const out = [];
      for (let i = min; i <= max; i++) out.push(i);
      return out;
    }
    // ===========================
    // â• ìœ ì‚¬ë„ ìš”ì²­ & ê²°ê³¼ ë°˜ì˜ (UI ìµœì†Œí™”)
    // ===========================
    async function fetchSimilarity(chunkRef) {
      try {
        const text = (chunkRef.text || '').trim();
        if (!text) return;

        // â‘  í›„ë³´ ìƒì„±: ìµœì´ˆ 1íšŒëŠ” ì „ì²´ ë¹„êµ â†’ candidates ìƒëµ
        const candidates = makeCandidateWindow(lastBestIdx);
        const body = candidates ? { text, candidates } : { text };

        const resp = await fetch('/similar', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const j = await resp.json();
        if (!(j && j.ok)) return;

        // â‘¡ ì ìˆ˜/ì¸ë±ìŠ¤ ë°˜ì˜
        const pctNum = typeof j.score_pct === 'number' ? j.score_pct : parseFloat(j.score_pct);
        const pct = isNaN(pctNum) ? 0 : pctNum;
        chunkRef.sim_pct = pct.toFixed(2);

        if (j.best_idx !== null && j.best_idx !== undefined) {
          lastBestIdx = j.best_idx; // ë‹¤ìŒ ì°½ì˜ ì¤‘ì‹¬

          // 90% ì´ìƒì´ë©´ ì§„í–‰ë„ ê°±ì‹ 
          if (pct >= MATCH_THRESHOLD) {
            const line = scriptLines.find(l => l.idx === j.best_idx);
            if (line) {
              if (!sceneProgress.has(line.scene)) sceneProgress.set(line.scene, new Set());
              sceneProgress.get(line.scene).add(line.idx);
            }
            // UI ë°˜ì˜ + íŠ¸ë¦¬ê±° í™•ì¸
            highlightScriptLine(j.best_idx);
            checkSceneTrigger(j.best_idx, pct);
          }
        }
      } catch (e) {
        console.error('similarity fetch failed', e);
      }
    }


    // ğŸ”µ ìŠ¤í¬ë¦½íŠ¸ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸ + ìë™ ìŠ¤í¬ë¡¤ (ëˆ„ì  ìœ ì§€)
    function highlightScriptLine(bestIdx) {
      const target = document.querySelector(`.script-line[data-idx="${bestIdx}"]`);
      if (!target) return;
      target.classList.add('matched');
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // ===========================
    // WAV ì¸ì½”ë”©
    // ===========================
    function floatTo16BitPCM(view, offset, input) {
      for (let i = 0; i < input.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, input[i]));
        s = s < 0 ? s * 0x8000 : s * 0x7FFF;
        view.setInt16(offset, s, true);
      }
    }
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
    }
    function encodeWAV(samples, sampleRate) {
      const numChannels = 1;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = samples.length * bytesPerSample;

      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, 'WAVE');

      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bytesPerSample * 8, true);

      writeString(view, 36, 'data');
      view.setUint32(40, dataSize, true);

      floatTo16BitPCM(view, 44, samples);
      return new Blob([view], { type: 'audio/wav' });
    }

    function showClosed() {
      actorClosedEl.classList.add('show');
      actorOpenEl.classList.remove('show');
    }
    function showOpen() {
      actorOpenEl.classList.add('show');
      actorClosedEl.classList.remove('show');
    }

    function startSpeakingAnim() {
      if (speakingTimer) return; // ì´ë¯¸ ì¬ìƒ ì¤‘
      // ì¦‰ì‹œ ì˜¤í”ˆìœ¼ë¡œ ì‹œì‘ (ë” ìì—°ìŠ¤ëŸ¬ìš°ë©´ showClosed()ë¡œ ì‹œì‘í•´ë„ ë¨)
      showOpen();
      speakToggle = false;
      speakingTimer = setInterval(() => {
        speakToggle = !speakToggle;
        if (speakToggle) showClosed(); else showOpen();
      }, ACTOR_FRAME_MS);
    }

    function stopSpeakingAnim() {
      if (speakingTimer) {
        clearInterval(speakingTimer);
        speakingTimer = null;
      }
      // ì¹¨ë¬µì¼ ë•ŒëŠ” ì… ë‹¤ë¬¸ í”„ë ˆì„ ìœ ì§€
      showClosed();
    }

    // ===========================
    // âœ… STT í”„ë¡ì‹œ í˜¸ì¶œ (ë¡œê·¸ UI ì œê±°)
    // ===========================
    async function sendChunkToWhisper_HTTP(chunkRef) {
      try {
        const startIdx = Math.max(0, Math.floor(chunkRef.start * sampleRate));
        const endIdx   = Math.min(channelData.length, Math.floor(chunkRef.end * sampleRate));
        const mono = channelData.subarray(startIdx, endIdx);
        const wavBlob = encodeWAV(mono, sampleRate);

        const fd = new FormData();
        fd.append('file', wavBlob, 'chunk.wav');

        const resp = await fetch('/stt-proxy', { method: 'POST', body: fd });
        const j = await resp.json();

        if (j.ok) {
          chunkRef.text = j.text || '';
          chunkRef.total_s = j.total_s;
          chunkRef.stt_s = j.stt_s;
          chunkRef.net_s = j.net_s;
          await fetchSimilarity(chunkRef);
        } else {
          console.error('stt error:', j.error || resp.status);
        }
      } catch (e) {
        console.error('sendChunkToWhisper_HTTP error', e);
      }
    }

    // ===========================
    // í´ë§ ë£¨í”„ (RMS ê¸°ë°˜) â€” UI ì¶œë ¥ ì—†ì´ ë™ì‘
    // ===========================
    function poll() {
      if (!audioBuffer) return;
      
      const sr = sampleRate;
      const windowSize = Math.floor(RMS_WINDOW_SEC * sr);

      const endIndex = Math.floor(playerEl.currentTime * sr);
      const startIndex = Math.max(0, endIndex - windowSize);
      const samples = channelData.subarray(startIndex, endIndex);
      const rms = calculateRMS(samples);

      const talkingNow =
        isTalkingVisual
          ? (rms >= threshold * TALK_OFF_FACTOR)   // ë‚´ë ¤ê°ˆ ë• ì•½ê°„ ê´€ìš©
          : (rms >= threshold * TALK_ON_FACTOR);   // ì˜¬ë¼ê°ˆ ë• ê¸°ì¤€ ê·¸ëŒ€ë¡œ
      
      if (talkingNow && !isTalkingVisual) {
        startSpeakingAnim();       // ì¦‰ì‹œ ì‹œì‘
        isTalkingVisual = true;
      } else if (!talkingNow && isTalkingVisual) {
        stopSpeakingAnim();        // ì¦‰ì‹œ ì •ì§€(ì… ë‹¤ë¬¸ ìƒíƒœ)
        isTalkingVisual = false;
      }

      const speakingNow = rms > threshold;
      if (speakingNow) {
        if (!isSpeaking) {
          isSpeaking = true;
          currentChunkStart = Math.max(0, playerEl.currentTime - RMS_WINDOW_SEC);
          silenceAccumMs = 0;
        } else {
          silenceAccumMs = 0;
        }
      } else {
        if (isSpeaking) {
          silenceAccumMs += POLL_MS;
          if (silenceAccumMs >= SILENCE_MS_TO_SPLIT) {
            const chunkEnd = Math.max(0, playerEl.currentTime - (silenceAccumMs / 1000));
            if (currentChunkStart != null && chunkEnd - currentChunkStart > 0.05) {
              const chunk = { start: currentChunkStart, end: chunkEnd, text: "" };
              chunks.push(chunk);
              sendChunkToWhisper_HTTP(chunk);
            }
            isSpeaking = false;
            currentChunkStart = null;
            silenceAccumMs = 0;
          }
        } else {
          silenceAccumMs = Math.min(silenceAccumMs + POLL_MS, SILENCE_MS_TO_SPLIT);
        }
      }
    }

    // ===========================
    // ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ & ë Œë”
    // ===========================
    async function loadAndRenderScript() {
      const res = await fetch('/script');
      const j = await res.json();
      if (!j.ok) throw new Error('script load failed');

      scriptLines = j.lines || [];
      sceneCount = j.scene_count || 0;

      // ì”¬ ë§µ êµ¬ì„±
      linesByScene.clear();
      lastIdxByScene.clear();
      for (const { idx, text, scene } of scriptLines) {
        if (!linesByScene.has(scene)) linesByScene.set(scene, []);
        linesByScene.get(scene).push(idx);
      }
      for (const [scene, arr] of linesByScene.entries()) {
        arr.sort((a,b)=>a-b);
        lastIdxByScene.set(scene, arr[arr.length-1]);
      }

      // ë Œë”
      scriptCountEl.textContent = j.count ?? scriptLines.length;
      sceneCountEl.textContent = sceneCount;
      scriptBoxEl.innerHTML = '';

      const frag = document.createDocumentFragment();

      // ì”¬ ë²ˆí˜¸ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ê·¸ë£¹ ìƒì„±
      const sortedScenes = [...linesByScene.keys()].sort((a,b)=>a-b);
      for (const scene of sortedScenes) {
        const group = document.createElement('section');
        group.className = 'scene-group';
        group.setAttribute('data-scene', scene);

        // ì”¬ í—¤ë”
        const header = document.createElement('div');
        header.className = 'scene-header';
        header.innerHTML = `
          <div class="scene-title">ğŸ¬ Scene ${scene}</div>
          <div class="scene-meta mono">${linesByScene.get(scene).length} lines</div>
        `;
        group.appendChild(header);

        // ì”¬ ë‚´ìš©
        const body = document.createElement('div');
        body.className = 'scene-body';

        for (const idx of linesByScene.get(scene)) {
          const lineObj = scriptLines[idx];
          const row = document.createElement('div');
          row.className = 'script-line';
          row.dataset.idx = lineObj.idx;
          row.setAttribute('data-idx', lineObj.idx);
          row.setAttribute('data-scene', scene);

          const num = document.createElement('span');
          num.className = 'script-num mono';
          num.textContent = `${lineObj.idx}.`;

          const content = document.createElement('span');
          content.className = 'script-text';
          content.textContent = lineObj.text;

          row.appendChild(num);
          row.appendChild(content);
          body.appendChild(row);
        }

        group.appendChild(body);
        frag.appendChild(group);
      }

      scriptBoxEl.appendChild(frag);
    }

    // ğŸ”µ ìŠ¤í¬ë¦½íŠ¸ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸ + ìë™ ìŠ¤í¬ë¡¤ (ì”¬ ê·¸ë£¹ ê°•ì¡° í¬í•¨)
    function highlightScriptLine(bestIdx) {
      const target = document.querySelector(`.script-line[data-idx="${bestIdx}"]`);
      if (!target) return;
      // ê¸°ì¡´ ë¼ì¸ ê°•ì¡°
      target.classList.add('matched');

      // ì†Œì† ì”¬ ê°•ì¡° & ì•½í•œ í„ìŠ¤
      const scene = target.getAttribute('data-scene');
      const group = document.querySelector(`.scene-group[data-scene="${scene}"]`);
      if (group) {
        group.classList.add('active');
        clearTimeout(group._pulseTimer);
        group.classList.add('pulse');
        group._pulseTimer = setTimeout(() => group.classList.remove('pulse'), 700);
      }

      // ë³´ê¸° ì˜ì—­ ì¤‘ì•™ ë°°ì¹˜
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // ===========================
    // ì´ˆê¸°í™”
    // ===========================
    async function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // ì´ˆê¸° ë°°ê²½: scene0
      changeBackground(0);

      const res = await fetch(playerEl.src);
      if (!res.ok) {
        alert("â— audio fetch failed");
        return;
      }
      const arrayBuf = await res.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuf);
      sampleRate = audioBuffer.sampleRate;
      channelData = audioBuffer.getChannelData(0);

      if (!pollingTimer) pollingTimer = setInterval(poll, POLL_MS);
    }

    // ì´ë²¤íŠ¸
    playerEl.addEventListener('play', () => { if (audioCtx) audioCtx.resume(); });
    playerEl.addEventListener('seeked', () => { silenceAccumMs = 0; });
    playerEl.addEventListener('ended', () => {
      if (!audioBuffer) return;
      if (isSpeaking && currentChunkStart != null) {
        const chunk = { start: currentChunkStart, end: audioBuffer.duration, text: "" };
        chunks.push(chunk);
        sendChunkToWhisper_HTTP(chunk);
      }
      isSpeaking = false;
      currentChunkStart = null;
      silenceAccumMs = 0;
      if (isTalkingVisual) {
        stopSpeakingAnim();
        isTalkingVisual = false;
      }
    });

    // ì‹œì‘
    (async () => {
      try {
        await loadAndRenderScript();
        await initAudio();
      } catch (e) {
        console.error(e);
        alert('ì´ˆê¸°í™” ì‹¤íŒ¨: ' + e.message);
      }
    })();
  </script>
</body>
</html>
